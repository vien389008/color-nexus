<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Flow Generator - Guaranteed Solvable</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
      body {
        font-family: monospace;
        background: #111;
        color: #0f0;
        padding: 20px;
      }
      button {
        padding: 10px 20px;
        margin-bottom: 20px;
        cursor: pointer;
      }
      pre {
        white-space: pre-wrap;
      }
    </style>
  </head>

  <body>
    <button id="generate">Generate 20 Maps</button>
    <pre id="output"></pre>

    <script>
      $(function () {
        const SIZE = 4;
        const TOTAL = SIZE * SIZE;
        const MAP_COUNT = 20;

        function xyToIndex(x, y) {
          return y * SIZE + x;
        }

        function indexToXY(i) {
          return { x: i % SIZE, y: Math.floor(i / SIZE) };
        }

        function neighbors(i) {
          const { x, y } = indexToXY(i);
          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];
          const result = [];

          for (let d of dirs) {
            const nx = x + d[0];
            const ny = y + d[1];
            if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE) {
              result.push(xyToIndex(nx, ny));
            }
          }
          return result;
        }

        function isInner(i) {
          const { x, y } = indexToXY(i);
          return x > 0 && x < SIZE - 1 && y > 0 && y < SIZE - 1;
        }

        function randomColor() {
          const min = 80;
          const max = 200;
          const r = Math.floor(Math.random() * (max - min)) + min;
          const g = Math.floor(Math.random() * (max - min)) + min;
          const b = Math.floor(Math.random() * (max - min)) + min;
          return (
            "#" +
            r.toString(16).padStart(2, "0") +
            g.toString(16).padStart(2, "0") +
            b.toString(16).padStart(2, "0")
          );
        }

        function generateSingleMap() {
          while (true) {
            // 1️⃣ Pick connector
            const innerCells = [];
            for (let i = 0; i < TOTAL; i++) {
              if (isInner(i)) innerCells.push(i);
            }
            if (!innerCells.length) continue;

            const connector =
              innerCells[Math.floor(Math.random() * innerCells.length)];

            const used = new Set([connector]);

            // 2️⃣ Build two independent branches
            function buildPath(start) {
              const path = [start];
              let current = start;

              const length = Math.floor(Math.random() * 3) + 2;

              for (let step = 0; step < length; step++) {
                const options = neighbors(current).filter((n) => !used.has(n));

                if (!options.length) break;

                const next =
                  options[Math.floor(Math.random() * options.length)];
                used.add(next);
                path.push(next);
                current = next;
              }

              return path;
            }

            const branch1 = buildPath(connector);
            const branch2 = buildPath(connector);

            if (branch1.length < 2 || branch2.length < 2) continue;

            const path1 = branch1;
            const path2 = branch2;

            const endpoints = [];
            const usedColors = new Set();

            let color1 = randomColor();
            let color2 = randomColor();
            while (color2 === color1) {
              color2 = randomColor();
            }

            endpoints.push({ index: path1[1], color: color1 });
            endpoints.push({ index: path1[path1.length - 1], color: color1 });

            endpoints.push({ index: path2[1], color: color2 });
            endpoints.push({ index: path2[path2.length - 1], color: color2 });

            const blocked = [];
            for (let i = 0; i < TOTAL; i++) {
              if (!used.has(i)) blocked.push(i);
            }

            return {
              size: SIZE,
              endpoints,
              blocked,
              connectors: [connector],
            };
          }
        }

        $("#generate").click(function () {
          $("#output").text("Generating... ⏳");

          setTimeout(() => {
            let output = "";

            for (let i = 1; i <= MAP_COUNT; i++) {
              const map = generateSingleMap();

              output += `// Map ${i}\n`;
              output += `{\n`;
              output += `  size: ${map.size},\n`;
              output += `  endpoints: [\n`;

              map.endpoints.forEach((e, idx) => {
                output += `    { index: ${e.index}, color: "${e.color}" }`;
                if (idx < map.endpoints.length - 1) output += ",";
                output += "\n";
              });

              output += `  ],\n`;
              output += `  blocked: [${map.blocked.join(", ")}],\n`;
              output += `  connectors: [${map.connectors.join(", ")}],\n`;
              output += `},\n\n`;
            }

            $("#output").text(output);
          }, 100);
        });
      });
    </script>
  </body>
</html>
